---- **ch1** ----
# Preface 
 
## Chapter Introduction: Bridging the Past and the Present of Computing

### The Digital Genesis

Welcome to an enlightening journey through the history and evolution of computer operating systems (OS) and programming languages (PL), the lifeblood of modern technology. This book is designed not only to chronicle the milestones that have shaped computing but also to provide an accessible and engaging narrative, unlocking the stories behind the code and interfaces we interact with daily.

As we embark on this exploration, we begin by addressing core concepts crucial to understanding the breadth of our topic:

- **Foundational Definitions**: Grasp the essential functions and purposes of both OS and PL. Learn how they work together to create the seamless computing experiences that power our world.
- **The Chronological Tapestry**: A timeline that serves as our map, marking the historical development of these technologies from their inception to their contemporary state.

### Unveiling Milestones and Innovations

Tracing the footprints of progress, the book promises a chronological voyage. We shall witness how necessities and invention gave birth to the first rudimentary batch processing systems, how multitasking revolutionized the work environment, and how primitive coding systems evolved into sophisticated languages that catapult computing possibilities.

As we delve into the fabric of technological breakthroughs, we will:
- **Illuminate Key Events**: Cast a spotlight on the innovations and contextualize them within the eras they were born.
- **Prepare Each Step of the Journey**: Offer a detailed guide through the history, marking each evolution and revolution in OS and PL.

### Diving Deep into the Evolutionary Pool

This book is not just a linear account but an intricate study that encompasses:
- **The Silhouette of Progress**: Understand the necessity of historical perspective to appreciate current technologies and anticipate the future.
- **The Labyrinth of Technology**: Trace the sophisticated web of OS features, transitions, and the progression of PL that have provided us with better development tools and user experiences.
- **Profiles of Pioneers**: Offer homage to the individuals and entities who've carved benchmarks in computing history.
- **Case Studies and Code Samples**: Breathing life into the abstract with practical applications, we'll provide tangible examples of how OS and PL are harnessed in real-world scenarios.

### Comparative Lens and Prognostications

To offer a multi-faceted view, the book also incorporates:
- **Comparative Analysis**: An examination of various technologies, their interactions, and how they've influenced one another.
- **Technological Assessments**: Measuring the impact and pinpointing the reasons behind the success (or limitations) of various computing technologies.

### Structuring the Past, Present, and Future

With a meticulous organization, the book is partitioned into six comprehensive parts:

- **Parts I and II**: Guide you through the historical pathways of OS and PL, celebrating pivotal moments and dissecting technical evolutions.
- **Parts III and IV**: Unravel current titans of the OS and PL landscapes with in-depth analyses, exploring their dominance and intricacies.
- **Part V**: Presents a side-by-side scrutiny, unpacking each system and language's unique attributes and contributions.
- **Part VI**: Forecasts the trajectory based on the echoes from the past, offering a vision for future explorations.

Concluding with appendices and a reflection on the symbiosis between OS and PL, this book is an encyclopedic nexus for students, professionals, and enthusiasts alike, seeking comprehension and inspiration from the annals of computer science history. Join us as we traverse the rich legacy that brings the virtual into reality, and decipher how yesterday's innovations are paving the way for tomorrow's breakthroughs.
 
---- **ch1-section1** ----
 
## Introduction to Operating Systems and Programming Languages
 
---- **ch1-section1-body** ----
 
#### Introduction to Operating Systems and Programming Languages

In this critical exploration of the section dedicated to "Introduction to Operating Systems and Programming Languages," we delve into the foundational pillars of modern computing: operating systems (OS) and programming languages. While the broader document encapsulates the rich tapestry of computing history, this section serves as both the anchor and the compass—orienting readers with its purpose and scope, underscoring its subjects' significance, and providing a roadmap of historical foundations and developments.

##### Overview of the Book

The purpose and scope of the book are manifestly twofold: firstly, to chart the evolution of operating systems and programming languages, and secondly, to acknowledge their quintessential roles in the annals of computing. The section promises a journey that begins with the seminal developments in OS and programming language history and culminates in an assessment of their contemporary relevance and applications.

**Subtopic Analysis:**

- **Purpose and Scope**: This subsection firmly establishes the primary aim: tracing the developmental arcs of OS and programming languages. It also reassures the reader that while the subject matter is vast, the structure and flow of the book are designed to facilitate comprehension and evoke curiosity.
- **Structure and Content of the Book**: A touchstone for readers, this meta-commentary hints at the upcoming chapters that dissect and discuss the book's content. It discreetly prepares the reader for a structured historical odyssey.

##### Significance of Operating Systems and Programming Languages

The true essence of this literary work emerges in the definition and significance of its central themes.

**Subtopic Analysis:**

- **Defining Operating Systems and Programming Languages**: Here, we encounter fundamental definitions—a crucial foundation laid out for novices and experts alike. It articulates the function of operating systems as the arbiters of hardware and software resources and describes programming languages as the vital vehicles of human-computer interaction.

##### Historical Foundations of Computing

Teasing an intriguing historical perspective, this prelude alludes to civilization's earliest compute mechanisms that would eventually give rise to both operating systems and programming languages.

**Subtopic Analysis:**

- **Early Computational Tools**: We anticipate historical expositions on pre-digital computation, serving as a contextual backdrop for understanding the genesis and necessity of operating systems and programming languages.

##### Milestones in the Development of Operating Systems

Evoking visions of computing's timeworn voyage, this section promises detailed examinations of significant evolutionary leaps—from unassuming batch processing systems to sophisticated, multi-tasking, and interactive computing paradigms.

**Subtopic Analysis:**

- **From Batch Processing to Interactive Computing**: Readers should expect narrative bridges connecting various eras of computing, bringing to life the sprints and strides of operating system innovation.

##### The Evolution of Programming Languages

Complementing the OS narrative is the chronicle of programming languages: their inception, their transformations, and their ceaseless progression towards refinement and power.

**Subtopic Analysis:**

- **The Genesis of Programming Languages**: An alluring teaser for the tales of the first programming languages and the early coding systems that redefined human ingenuity and computational complexity.

##### Inventions Leading to Modern Operating Systems and Programming Languages

Progress in computing is often synonymous with technological breakthroughs; this section ambitiously pledges to spotlight those radical innovations that shepherded in the modern computing epoch.

**Subtopic Analysis:**

- **Technological Breakthroughs**: A promise to not only list but to contextualize key inventions, mapping out how they catalyzed the development of operating systems and programming languages.

##### Chapter-by-Chapter Walkthroughs

Astutely, this portion prefigures two series of chapter overviews—one each for operating systems and programming languages. They indicate a deep dive into every seminal development and contributor in these domains, ranging from mainframe systems to the ubiquity of mobile OS, and from machine languages to the paradigms shaping modern programming.

**Subtopic Analysis:**

- Two detailed walkthrough segments are presented: one for **Operating Systems** and another for **Programming Languages**. Each bullet point suggests a chapter focusing on a particular era or aspect of its subject, ensuring that readers are primed for comprehensive analysis in subsequent chapters.

##### Conclusion

In conclusion, this section of text fulfills its role admirably, offering a tantalizing preview of the book's encyclopedic discourse on operating systems and programming languages. It manages to simultaneously inform, preview, and entice: a balance that bodes well for the rest of the scholarly endeavor.

**Subtopic Analysis:**

Reflecting on this section as a whole, one can appreciate its narrative prowess, how it sets the stage for an in-depth historical examination. Through well-defined subtopics, readers are promised a journey from the rudiments of computing's past to the cutting-edge of its present—with a perspective on future directions. The section achieves considerable depth within its scope, all while maintaining an awareness of the reader's need for clear guidance and logical organization. This introduction serves not only as a gateway but also as an insightful prologue to the unfolding story of operating systems and programming languages.
 
---- **ch1-section2** ----
 
## The relevance of studying the history of OS and programming languages
 
---- **ch1-section2-body** ----
 
### Detailed Treatment of the History of Operating Systems and Programming Languages

#### Introduction

The study of the history of operating systems (OS) and programming languages is a window into the progression of computing technology. This section delves into various aspects that illustrate why this historical overview is not just important for academic curiosity but also instrumental in shaping modern computing practices. Each subtopic within this section connects the past with the present, revealing the foundations that have guided the evolution of computing technologies. 

#### Understanding the Evolution

An in-depth exploration of the early computational systems helps us understand their transformation into today's advanced software. A chronological examination shows that the move from command-line interfaces to graphical user interfaces was a major leap that made computers more accessible to a wider audience.

##### Explore Historical Progression

Chronologically tracing the evolution gives clarity on how distinct technological innovations built upon each other. This includes the vital shift from single-task systems to those that managed multiple tasks simultaneously, setting the stage for the diverse computing ecosystems we have today.

##### Examine User Interfaces

The gradual improvement of user interfaces significantly broadened the accessibility and usability of computers. We analyze how the advent of graphical user interfaces marked a pivotal moment when computers transcended from specialist tools to a mainstream commodity.

#### Appreciating Key Inventions and Contributions

Innovations in both operating systems and programming languages have been defining moments in the history of computing. By highlighting these milestones, we commemorate the critical leaps forward.

##### Highlight Key Inventions 

Identifying major inventions such as time-sharing systems, object-oriented programming, and the development of UNIX puts into context the advancements that shaped our current computing landscape. We assess how each invention solved specific problems and sparked new possibilities.

##### Recognize Pioneers

Individuals and organizations are spotlighted to showcase the human element behind these technological breakthroughs. Their stories provide a deeper understanding of the creativity and perseverance that propelled the field forward.

#### Gaining Insight into Operating Systems

By dissecting various operating systems throughout history, we chart their defining characteristics and the reasons they became benchmarks for subsequent systems.

##### Detail Major OS Characteristics 

Investigating key features like multitasking capability and memory management offers an understanding of how each operating system addressed specific user needs.

##### Analyze Architectural Changes

Examining transitions in architecture, such as the move from batch processing to time-sharing, details the technical and conceptual changes that OS have undergone.

#### Exploring Programming Languages

The journey from the era of low-level programming to the abundance of high-level languages reveals a constant pursuit of efficiency, readability, and flexibility in software development.

##### Chart Development of Languages

We track the evolutionary path of programming languages, observing how the industry's requirements directed the creation of new language constructs and paved the way for innovative programming paradigms.

#### Learning from In-Depth Case Studies

For a practical understanding, we merge theory with reality by scrutinizing the operating systems and programming languages that dominate today's computing landscape.

##### Provide Comprehensive Chapters

In-depth studies on market leaders like Windows, iOS, and Python give us tangible illustrations of how operating systems and languages have adapted to user requirements and technological advances over time.

#### Providing Concrete Examples

Using examples and code snippets, we offer a hands-on look at how different programming languages and operating systems operate, enriching the reader's comprehension with practical insights.

##### Incorporate Syntax and Usage Demos

By creating simple example programs, readers can appreciate the distinct syntax and application of various programming languages, thereby understanding their unique advantages and design philosophies.

#### Profiling Innovators and Influencers

By profiling notable figures and their contributions, we gain insights into the driving forces behind these influential technologies.

##### Document Pioneers

Portraying the lives and achievements of innovators adds a personal dimension to our understanding of technology development, emphasizing the impact of individuals on the larger narrative.

#### Comparing Systems and Languages

Comparison offers perspective. Showcasing how different technologies evolved in parallel and sometimes in response to each other provides a holistic view of the computing field.

##### Highlight Evolution and Divergence

We look at the cross-pollination of ideas and how competition and collaboration among various systems and languages led to the diverse technological ecosystem we have today.

#### Evaluating Advantages and Disadvantages

By evaluating the strengths and weaknesses of different technologies, we can understand why certain systems thrived while others did not.

##### Analyze Context-Specific Strengths

This analysis gives a nuanced view of how specific environments or tasks can dictate the suitability of an operating system or programming language.

#### Assessing Current and Historical Usage

Reflecting on past practices allows us to understand the foundation on which current technologies are built and how they continue to evolve.

##### Reflect on Adoption and Development

Recognizing the forces that drove historical adoption gives us crucial insight into the successes and failures of various computing practices.

#### Envisioning the Future

What lies ahead? Understanding the past channels our speculation about the future, allowing us to predict developments and prepare for upcoming changes.

##### Speculate on Future Standards

We use lessons from past trends to make educated guesses about upcoming norms in operating systems and programming languages, offering a foresight into the field's trajectory.

#### Conclusion

In sum, an examination of the history of operating systems and programming languages is not only about understanding where we've been, but also about setting the stage for where we are going. Each subtopic uncovers layers of innovation, struggle, and collaboration that have scripted the remarkable history of computing technologies. This detailed treatment underlines the importance of retrospection in understanding current technologies and anticipating their future. It is a tapestry woven from the achievements of the past, informing the advances of the future and acknowledging the people who turned visions into reality.
 
---- **ch1-section3** ----
 
## Outline of the book's structure and purpose
 
---- **ch1-section3-body** ----
 
### Detailed Treatment of the Book's Structure and Purpose

#### Introduction

The section isolated for in-depth analysis details the structure and purpose of a comprehensive book on the intertwined history of operating systems (OS) and programming languages (PL). It presents an organized journey from the inception of these technologies to modern-day advancements and speculations about the future. The document clearly segments the topics into parts, each focusing on specific eras, developments, and analyses. The introductory aspect emphasizes the evolution of OS and PL, and the importance of historical context. This treatment will unpack each listed subtopic within this section to offer deeper insights into the book's intended content and educational value.

#### Part I: Historical Journey Through Operating Systems

- **Chapter 1: The Dawn of Modern Computing**
  - This chapter is designed to set the stage for the role of OS in modern computing, starting with foundational inventions and progressing to early systems that laid the groundwork for more complex OS.

- **Chapter 2: The Mainframe Era**
  - The mainframe era is profiled, highlighting the distinctive features of the OS of that time and introducing pivotal figures and corporations instrumental in shaping the computing landscape.

- **Chapter 3: The Microcomputer Revolution**
  - This chapter addresses the significant shift from mainframes to the more individual-centric microcomputers, delving into the OS that powered these accessible machines.

- **Chapter 4: The Rise of Personal Computing**
  - As personal computing took off, the OS evolved, offering more sophisticated user interfaces and features that catered to non-specialist users.

- **Chapter 5: Networked and Distributed Systems**
  - The development of OS designed for networking and distributed environments illustrated the changing demands placed on computing systems by connectedness and remote operation.

- **Chapter 6: The Mobile and Cloud Paradigm**
  - Recognizing the latest paradigm shifts, this chapter introduces mobile and cloud computing OS, showing how they've adapted to new hardware and user expectations.

#### Part II: Historical Journey Through Programming Languages

The second part mirrors the first, but with a focus on programming languages, detailing the evolutionary path from basic coding systems to sophisticated languages designed for myriad applications.

- **Chapters 7 to 10**
  - These chapters are structured to guide the reader through various stages and paradigms in programming language development, including procedural, object-oriented, visual, and domain-specific languages.

#### Part III and Part IV: In-Depth Analysis of Contemporary OS and Programming Languages

- **Chapters 11 to 18**
  - A comprehensive look at modern contenders in the OS and PL spheres is provided, with profiles on Windows, MacOS, Linux, Android, iOS, Python, JavaScript, Java, and C/C++.

#### Part V: Comparing Operating Systems and Programming Languages

- **Chapters 19 to 20**
  - Comparative analysis offers critical examinations of OS and PL, aiding readers in understanding their differentiating attributes and selecting the right tool for specific use cases.

#### Part VI: Impact and Legacy in Computer Science

- **Chapters 21 to 22**
  - Assessing the long-term effects legacy systems have on today's computing environment and forecasting potential future trends that could redefine OS and PL.

#### Appendices and Conclusion

The document concludes with useful appendices providing a glossary, a timeline of development, and resources for further reading, followed by a concluding chapter that encapsulates the historical connection between OS and PL, reflecting on their joint evolution and impact on the modern world.

#### Conclusion

The book's clear layout aids comprehension of the complex intertwining of OS and PL history, providing the reader with a well-rounded understanding of these critical components in the computer science landscape. The purposeful division into time periods, landmark developments, and comparative analyses offers invaluable perspective on how the past shapes the present, setting expectations for the impacts and evolution of technology in the future.
 
---- **ch1-case-study** ----
 
## Case Study (Fictional)
 
### Case Study: The LegacyOS Challenge – From Chaos to Clarity

#### Introduction to Team Legacy

At the heart of our case study is Team Legacy—a quintet of spirited software engineers with a predilection for historical software. Sophie, our systems architect, known for her puns and a penchant for classic rock; Jack, the lead developer, who never backs down from a technical dare; Maya, always the mediator, doubling as a quality assurance expert and the team's resident espresso connoisseur; Raj, the project manager with a sticky note for every occasion; and Lena, the documentation specialist with a novel approach to team building exercises—involving cats.

#### The Dilemma of Yore

LegacyOS started as a post-academic project to resurrect an operating system from the 80s and integrate it with modern hardware. The problem was non-trivial—how could a team give new life to an OS that was contemporaneous with the release of the original Rubik's Cube?

##### Goals and Solutions

The team aimed to revivilize the antiquated OS while enhancing its capacity to execute modern programming languages like Python. One solution was to rewrite the OS kernel. Another was to build a layer that would abstract the old system calls and adapt them to current expectations.

##### Experiments and Selection of the Solution

The kernel rewrite was a Sisyphean task; Jack cracked jokes about 'recoding in hieroglyphics.’ The abstraction layer, while challenging, seemed more practical. Tests included a colorful array of failures, leading Sophie to quip, "If bugs were currency, we'd be financial moguls."

##### Implementing the Solution

Maya organized a rigorous workflow to document every step. Under Sophie’s architecture, they built the layer—cleverly named 'ChronoAdapter.' Raj kept the timeline in check, marking milestones with celebratory sticky notes. Lena's documentation included doodles that, surprisingly, clarified complex concepts.

##### Results and Triumphs

After months marinated in coffee and classic rock anthems, Team Legacy's efforts paid dividends. The revamped LegacyOS was a bridge between eras, running Python scripts while preserving its original charm. In a twist, even contemporary developers found LegacyOS appealing for its simplicity and low resource usage.

#### Conclusion

In the final analysis, Team Legacy not only revivified an ancient OS but crafted a conduit through which historical and modern computing found harmony. Sophie summarized the experience as, "We didn't just solve a problem; we taught an old OS new tricks." The project demonstrated the value of a versatile team who embraced history, humor, and relentless problem-solving to carve out a niche in the future of computing.
 
---- **ch1-summary-begin** ----
 
## Chapter Summary
 
### Chapter Summary: Introduction to Operating Systems and Programming Languages

#### Introduction
The book starts by explaining the importance of understanding the history and evolution of operating systems (OS) and programming languages (PL), which are integral to the computing narrative. It aims to make these topics accessible and engaging for readers.

#### Summary of Content
The introductory section provides an overview of the book's content, including:
- **Basic Concepts**: Initiating with the definitions and significance of OS and PL.
- **Historical Background**: Presenting a historical backdrop for the emergence of OS and PL.
- **Significant Milestones**: Promising a chronological exploration of OS from batch processing to multitasking and of PL from early coding systems to today's advanced languages.
- **Technological Breakthroughs**: Highlighting the innovations that have shaped modern OS and PL, with the context of these developments.
- **Detailed Analysis**: Preparing the reader for in-depth, chapter-by-chapter exploration of OS and PL histories.
- **Comprehensive Examination**: Concluding the introduction with an anticipation of a thorough analysis, from foundational concepts to present-day innovations.

#### History of Operating Systems and Programming Languages
- **Historical Perspective**: Establishes the necessity of understanding the historical evolution for current and future technologies.
- **Exploration and Evolution**: Outlines the technological progression from simple to complex interfaces in OS and the advancement in user experience.
- **Innovations and Contributors**: Celebrates key developments and acknowledges individual and organizational pioneers shaping OS and PL.
- **OS Features and Transitions**: Analyzes the distinctive features and conceptual shifts in OS history.
- **PL Progression**: Chronicles the evolution from low-level to high-level languages for better software development tools.
- **Practical Applications**: Provides case studies and code examples to illustrate the practical implementation of OS and PL.
- **Innovator Profiles**: Adds a personal context to technology development through bios of key figures.
- **Comparative Analysis**: Looks at diverse computing technologies emerging from competition and collaboration.
- **Evaluation of Technologies**: Assesses the relative success or failure of various computing technologies.
- **Historical and Modern Usage**: Reflects on how past technologies have shaped our current computing domain.
- **Future Prospects**: Offers insights into potential future developments based on historical analysis.

#### Book Structure Overview
The book is organized into six parts:
- **Part I: Historical Journey Through OS**: From early computing to the rise of networked and mobile systems.
- **Part II: Historical Journey Through PL**: A parallel structure focusing on the development of programming languages.
- **Part III & IV: Contemporary OS and PL**: Examines current main players in the OS and PL fields with detailed profiles.
- **Part V: OS and PL Comparison**: Analyzes the different systems and languages for their unique attributes.
- **Part VI: Impact and Legacy**: Evaluates the lasting effect of legacy systems and anticipates future trends.

The book ends with appendices offering supplementary resources and a contemplation on the interplay and collective evolution of OS and PL.
 
---- **ch1-further-reading-begin** ----
 
## Further Reading
 
#### Further Reading

As you've ventured through this chapter, uncovering the rich tapestry of operating systems and programming languages, you may now wish to deepen your understanding of these pivotal elements in the digital world. Below, you'll find a curated selection of further readings that delve into the intricacies discussed throughout this comprehensive exploration.

##### Operating Systems

- **"Modern Operating Systems" by Andrew S. Tanenbaum**: Prentice Hall; 4th edition (March 20, 2014). This definitive guide provides an in-depth look at the design and functioning of modern operating systems, including case studies on Linux and Windows.
  
- **"Operating System Concepts" by Abraham Silberschatz, Peter B. Galvin, Greg Gagne**: Wiley; 10th edition (December 7, 2018). Often regarded as the ‘bible’ for OS, this book covers fundamental concepts as well as recent developments like cloud computing and mobile OS.

##### Programming Languages

- **"The Pragmatic Programmer: Your Journey to Mastery" by David Thomas and Andrew Hunt**: Addison-Wesley Professional; 20th Anniversary Edition (September 13, 2019). Focusing on best practices and practical tips, this book is a resource for mastering programming languages and becoming an adept coder.

- **"Programming Language Pragmatics" by Michael L. Scott**: Morgan Kaufmann; 4th edition (November 20, 2015). This book addresses the fundamentals of programming languages from a design and implementation perspective, ideal for understanding the evolution of PL.

##### Historical Perspectives

- **"Code: The Hidden Language of Computer Hardware and Software" by Charles Petzold**: Microsoft Press; 1st edition (October 11, 2000). Petzold retells the history of computing and programming languages in a narrative that caters to both beginners and seasoned technologists.

- **"The Soul of a New Machine" by Tracy Kidder**: Back Bay Books; (June 1, 2000). An award-winning classic, this book delves into the drama and tension behind the creation of a new computer, showcasing the human element in technological advancement.

##### Innovators and Influencers

- **"Masters of Doom: How Two Guys Created an Empire and Transformed Pop Culture" by David Kushner**: Random House Trade Paperbacks; (May 11, 2004). Explore the fascinating biographical account of John Carmack and John Romero, two trailblazers in game programming and software development.

- **"The Innovators: How a Group of Hackers, Geniuses, and Geeks Created the Digital Revolution" by Walter Isaacson**: Simon & Schuster; (October 7, 2014). Isaacson provides a comprehensive look at the individuals who paved the way for the digital era, including those behind crucial software innovations.

##### Comparative Analyses

- **"Clean Code: A Handbook of Agile Software Craftsmanship" by Robert C. Martin**: Prentice Hall; 1st edition (August 11, 2008). As "Uncle Bob" himself, Robert C. Martin shares principles and best practices for writing clean, maintainable code across programming languages.

- **"Design Patterns: Elements of Reusable Object-Oriented Software" by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides**: Addison-Wesley Professional; 1st edition (November 10, 1994). Uncover insights into commonalities between programming languages through reusable design patterns recognized by software architects worldwide.

##### Technological Assessments

- **"Artificial Intelligence: A Guide for Thinking Humans" by Melanie Mitchell**: Farrar, Straus and Giroux; (October 15, 2019). While this book focuses on AI, it provides context for the role that programming languages play in the future of technology and society.

##### Advancements and Projections

- **"Life After Google: The Fall of Big Data and the Rise of the Blockchain Economy" by George Gilder**: Gateway Editions; (July 17, 2018). Gilder speculates on the future landscape of computing, offering insights that may influence the next generation of operating systems and programming languages.

These readings will not only broaden your knowledge and perspective but also serve as stepping stones to further discovery in the world of computing. Whether you're interested in delving into the technical underpinnings, the historical context, or the impacts of these technologies on our society, these resources will guide your journey through the ever-evolving landscape of computer science.
 
